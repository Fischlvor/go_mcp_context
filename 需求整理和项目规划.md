# go-mcp-context 软件设计说明书（SDD）

**文档版本：** v1.0  
**最后更新：** 2025-01-05  
**文档状态：** 已实现

## 一、引言

### 1.1 系统标识

- **系统名称：** go-mcp-context
- **系统版本：** v1.0
- **开发语言：** Go 1.23.0
- **适用范围：** 企业内网 AI IDE 文档检索系统

### 1.2 系统概述

本系统是一个**私有化的 Context7 替代方案**，为企业内网的 CoStrict AI IDE 提供：
1. **实时、准确的技术文档和代码示例**（通过向量检索）
2. **标准 MCP 协议接口**（让 IDE 无缝集成）
3. **支持手动上传文档**（适应内网隔离场景）

**核心能力：**
- MCP Server 实现（JSON-RPC 2.0 + Streamable HTTP）
- 向量检索系统（PostgreSQL + pgvector）
- 多格式文档处理（Markdown、PDF、DOCX）
- 混合搜索与智能重排序
- GitHub 文档自动导入
- 多版本管理

### 1.3 文档概述

本文档是 go-mcp-context 系统的软件设计说明书（SDD），描述了系统的架构设计、详细设计、数据库设计和接口设计。本文档面向：
- 系统开发人员
- 系统维护人员
- 技术审查人员

### 1.4 设计基线

本设计基于以下需求和约束：
- 对标 Context7 的 MCP 工具设计
- 支持企业内网隔离环境部署
- 性能要求：文档更新 < 1分钟，检索延迟 < 1秒
- 技术栈：Go + PostgreSQL + Redis + Vue 3

### 1.5 参考系统对比

**Context7 核心能力对比：**

| 能力 | Context7 做法 | 本项目方案 |
|------|-------------|---------|
| **文档检索** | 向量化 + 向量搜索 | PostgreSQL + pgvector |
| **智能排序** | 5 指标重排序 | 简化版 3 指标 |
| **版本管理** | 支持库的多个版本 | 同样支持 |
| **MCP 接口** | 两个工具（search/get） | 同样实现 |
| **缓存优化** | Redis 多层缓存 | 同样实现 |

### 1.4 Context7 与本方案的主要差异

| 维度 | Context7 | 本项目 |
|------|---------|--------|
| **数据源** | 自动爬取 GitHub/NPM | **手动上传文档** |
| **部署方式** | 云服务（Upstash） | **私有化部署** |
| **网络环境** | 互联网 | **内网隔离** |
| **文档格式** | 主要是 Markdown | **多格式（PDF/DOCX/Swagger）** |
| **Embedding** | 云端 API | **本地或 OpenAI API** |

---

## 二、系统架构

### 2.1 两层架构（2025-12-15 更新）

> **架构调整**：从三层架构（Library → Document → Chunk）调整为两层架构（Library → Chunk），对标 Context7 的设计。

**调整原因：**
1. Context7 采用 Library 直接关联 Chunk 的设计
2. 简化版本管理：Library 只存库名，Chunk 存版本号
3. 支持多版本共存：同一库的不同版本 Chunks 独立存储
4. 满足性能要求："1min 内完成一个库的最新版本文档更新"

### 2.1.1 两层架构图

```
┌─────────────────────────────────────────┐
│         CoStrict IDE (MCP Client)       │
│  用户在 IDE 中提问 → MCP 协议请求      │
└────────────────┬────────────────────────┘
                 │ MCP Protocol (HTTP/SSE)
┌────────────────▼────────────────────────┐
│       MCP Server (Go + mcp-golang)      │
│  ┌──────────────┐  ┌──────────────┐    │
│  │search-libs   │  │get-library   │    │
│  │库名匹配      │  │文档检索      │    │
│  └──────────────┘  └──────────────┘    │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│     Business Logic Layer (Go)           │
│  ┌──────────────────────────────────┐  │
│  │ 向量检索 + 重排序 + 缓存         │  │
│  └──────────────────────────────────┘  │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│      Storage Layer                      │
│  ┌──────────────┐  ┌──────────────┐    │
│  │PostgreSQL    │  │Redis         │    │
│  │+ pgvector    │  │Cache         │    │
│  └──────────────┘  └──────────────┘    │
└─────────────────────────────────────────┘
```

### 2.2 两个核心流程

#### 流程 1：文档上传和处理（2025-12-15 更新）

```
用户上传文档（指定 library_id + version）
  ↓
上传文件到七牛云：/mcp/docs/{lib}/{version}/{filename}
  ↓
格式识别 (PDF/DOCX/MD/Swagger)
  ↓
文本提取 (docconv/gomarkdown)
  ↓
语义分块 (512 tokens + 50 overlap)
  ↓
调用 LLM 生成 Description（AI 富化）
  ↓
生成 Embedding (OpenAI Proxy API)
  ↓
存储 DocumentChunk 到 PostgreSQL + pgvector
  ↓
更新 Library.versions 列表
  ↓
Web 界面显示"上传成功"
```

**版本更新策略（同一大版本只保留最新小版本）：**
```
上传 React 19.0.1：
  ↓
查找同一大版本的旧版本（如 19.0.0）
  ↓
软删除旧版本的 Chunks 和 Uploads（status = 'deleted'/'replaced'）
  ↓
删除七牛云旧版本文件：/mcp/docs/react/19.0.0/*
  ↓
上传新版本文件：/mcp/docs/react/19.0.1/*
  ↓
生成新 Chunks
  ↓
更新 Library.versions：["19.0.1", "18.3.1", "17.0.2"]
```

#### 流程 2：CoStrict 查询文档

```
CoStrict IDE 用户提问
  ↓
MCP 请求 → search-libraries (库名匹配)
  ↓
MCP 请求 → get-library-docs (文档检索)
  ↓
生成查询向量
  ↓
PostgreSQL 向量搜索 (Top-50)
  ↓
简化重排序 (3 指标)
  ↓
返回 Top-10 结果给 IDE
  ↓
IDE 将文档注入到 LLM 上下文
  ↓
LLM 基于准确文档生成代码
```

---

## 三、技术栈

### 3.1 后端技术栈

| 组件 | 选型 | 关键理由 |
|------|------|---------|
| **Web 框架** | Gin | 高性能、生态成熟 |
| **MCP SDK** | mcp-golang | 生产级、类型安全 |
| **数据库** | PostgreSQL 15 | 统一存储、ACID 保证 |
| **向量扩展** | pgvector | 性能优异（11.4x 吞吐量） |
| **Embedding** | OpenAI text-embedding-3-small | 成本极低（$0.02/1M tokens） |
| **缓存** | Redis | 多层缓存热门查询 |
| **文档解析** | docconv + gomarkdown + go-openapi | 多格式支持 |
| **ORM** | GORM | 类型安全、易于维护 |

### 3.2 前端技术栈

```
Vue 3 + TypeScript + Vite
├── 文档上传界面
├── 库管理界面（版本、元数据）
├── 检索测试界面
└── 统计分析界面
```

**前端依赖：**
- vue@3.x - 核心框架
- vue-router@4.x - 路由管理
- pinia@2.x - 状态管理
- axios - HTTP 请求
- element-plus - UI 组件库
- vite - 构建工具

### 3.3 部署方案

```yaml
docker-compose.yml:
  - PostgreSQL 15 (+ pgvector)
  - Redis
  - Go MCP Server
  - Vue 3 前端
  - Nginx 反向代理
```

复用 `go_blog/docker-compose.base.yml` 中的 postgres 和 redis。

### 3.4 Go 依赖

```bash
# 核心依赖
- github.com/metoro-io/mcp-golang    # MCP SDK
- gorm.io/gorm                        # ORM
- gorm.io/driver/postgres             # PostgreSQL 驱动
- github.com/pgvector/pgvector-go     # pgvector 支持
- github.com/gin-gonic/gin            # Web 框架
- github.com/redis/go-redis/v9        # Redis 客户端

# 文档解析
- code.sajari.com/docconv             # PDF/DOCX 解析
- github.com/gomarkdown/markdown      # Markdown 解析
- github.com/go-openapi/spec          # Swagger 解析

# Embedding
- github.com/sashabaranov/go-openai   # OpenAI API
```

---

## 四、核心功能拆解

### 4.1 MCP Server（最关键）

#### 工具 1：search-libraries

**功能：库名搜索和版本查询**

```go
// 输入参数
{
  "libraryName": "react"  // 库名查询字符串
}

// 处理流程（向量搜索优先，模糊匹配降级）
1. 尝试向量搜索（优先策略）
   - 使用库的 embedding 向量进行语义搜索
   - 阈值：cosine distance < 0.7（相关）
   - 限制：Top-10
2. 如果向量搜索失败或无结果，降级到模糊匹配：
   a. 前缀匹配（name ILIKE 'react%'）
   b. 如果结果不足5条，补充包含匹配（name ILIKE '%react%'）
3. 计算匹配分数（0-1）：
   - 完全匹配：1.0
   - 前缀匹配：0.9
   - 包含匹配：0.8
   - Levenshtein 相似度：最高 0.7

// 输出格式
{
  "libraries": [
    {
      "library_id": 1,                    // 库ID（数字）
      "name": "React",                    // 库名
      "description": "A JavaScript library for building user interfaces",
      "versions": ["18.2.0", "18.3.0"],  // 可用版本列表
      "default_version": "18.3.0",       // 默认版本
      "snippets": 150,                    // 文档片段数（实际统计）
      "score": 0.95                       // 匹配分数（0-1）
    }
  ]
}
```

**关键设计：**
- 策略：向量搜索优先，模糊匹配降级
- 向量搜索阈值：distance < 0.7（过滤不相关结果）
- 模糊匹配：前缀优先，包含补充

---

#### 工具 2：get-library-docs

**功能：文档内容检索和混合搜索**

```go
// 输入参数
{
  "library_id": 1,           // 库ID（uint类型，0表示全局搜索）
  "mode": "code",            // code 或 info
  "topic": "hooks",          // 搜索主题/查询词
  "version": "18.3.0",       // 可选：指定版本
  "page": 1                   // 页码（1-10）
}

// 支持两种搜索模式：
// 1. 指定 library_id > 0：在特定库中搜索
// 2. library_id = 0：全局搜索所有库

// 处理流程
1. 生成查询向量（OpenAI Embedding）
2. 向量搜索：PostgreSQL + pgvector (Top-50)
3. 关键词搜索：PostgreSQL 全文搜索 (Top-50)
4. 混合搜索：合并结果，去重
5. 重排序：3 个指标
   - 向量相似度：50%
   - BM25 分数：30%
   - 文档热度：20%
6. Redis 缓存检查
7. 返回 Top-10 结果（第 (page-1)*10 到 page*10）

// 输出格式
{
  "library_id": 1,           // 库ID（0表示全局搜索）
  "documents": [
    {
      "title": "useEffect Hook Usage",
      "description": "Demonstrates how to use useEffect for side effects",
      "source": "react/18.3.0/hooks.md",
      "version": "18.3.0",
      "mode": "code",
      "language": "javascript",
      "code": "useEffect(() => { ... }, [deps])",
      "content": "...",      // info模式才返回
      "tokens": 120,
      "relevance": 0.88       // 综合相关性分数
    }
  ],
  "page": 1,
  "has_more": true
}
```

**关键参数：**
- mode：支持 "code"（API 参考 + 代码示例）和 "info"（概念指南）
- page：1-10（IDE 可请求多页获取更多上下文）
- limit：固定 10（每页 10 条结果）
- 重排序权重：0.5 + 0.3 + 0.2（向量权重最高）

### 4.2 前端功能说明

前端采用 Vue 3 + TypeScript + Vite 实现，提供以下核心功能：

**1. 库管理**
- 库列表展示（名称、版本、文档数、更新时间）
- 库搜索和过滤
- 库创建、更新、删除
- GitHub 导入功能

**2. 文档管理**
- 文档上传（支持 PDF、Markdown、DOCX）
- SSE 实时进度显示
- 文档列表和详情查看
- 文档版本管理

**3. 搜索测试**
- 库选择和版本切换
- 文档检索测试
- 结果展示（相关性分数、来源、内容预览）
- 分页支持

**4. 用户中心**
- SSO 登录
- API Token 管理（生成、查看、撤销）
- 个人信息展示

**5. 统计分析**
- 库统计（文档数、Chunk数、Token数）
- MCP 调用统计
- 系统性能监控

---

### 4.3 文档处理流程

#### 解析模块

```go
type DocumentParser interface {
    Parse(filePath string) ([]string, error)  // 返回文本块
}

// 实现多种格式
- MarkdownParser
- PDFParser (docconv)
- DocxParser (docconv)
- SwaggerParser (go-openapi)
```

#### 分块模块

```go
type Chunker interface {
    Chunk(text string) []Chunk  // 512 tokens + 50 overlap
}

type Chunk struct {
    Text      string
    StartPos  int
    EndPos    int
}
```

#### Embedding 模块

```go
type EmbeddingService interface {
    Embed(texts []string) ([][]float32, error)
}

// 实现
- OpenAIEmbedding (API 调用)
- LocalEmbedding (bge-m3 本地模型)
```

### 4.4 检索流程

#### 向量检索

```sql
SELECT document_chunks.*, 
       document_uploads.title as doc_title,
       embedding <=> query_embedding as distance
FROM document_chunks
LEFT JOIN document_uploads ON document_uploads.id = document_chunks.upload_id
WHERE document_chunks.status = 'active' 
  AND document_chunks.deleted_at IS NULL
  AND document_chunks.library_id = ?
  AND document_chunks.version = ?
  AND document_chunks.chunk_type = ?  -- code 或 info
ORDER BY distance ASC
LIMIT 50;
```

#### BM25 关键词搜索

```sql
SELECT document_chunks.*, 
       document_uploads.title as doc_title,
       ts_rank(document_chunks.chunk_tsvector_simple, plainto_tsquery('simple', ?)) as rank
FROM document_chunks
LEFT JOIN document_uploads ON document_uploads.id = document_chunks.upload_id
WHERE document_chunks.status = 'active' 
  AND document_chunks.deleted_at IS NULL
  AND document_chunks.library_id = ?
  AND document_chunks.version = ?
  AND document_chunks.chunk_tsvector_simple @@ plainto_tsquery('simple', ?)
ORDER BY rank DESC
LIMIT 50;
```

#### 混合搜索和 RRF 重排序

**搜索策略：混合搜索 + RRF（Reciprocal Rank Fusion）算法**

```
向量搜索 (Top-50)          BM25 搜索 (Top-50)
     ↓                          ↓
  cosine 距离              ts_rank 分数
     ↓                          ↓
  Min-Max 归一化           Min-Max 归一化
     ↓                          ↓
  ┌──────────────────────────────┐
  │    RRF 算法合并               │
  │    基于排名而非分数           │
  └──────────────────────────────┘
           ↓
  ┌──────────────────────────────┐
  │  RRF 分数计算                 │
  │  + 向量 RRF (70%)             │
  │  + BM25 RRF (30%)             │
  │  + 热度加成 (20%)             │
  └──────────────────────────────┘
           ↓
  ┌──────────────────────────────┐
  │  返回 Top-10 结果             │
  │  (分页: page * 10)            │
  └──────────────────────────────┘
```

**RRF 重排序公式：**

```go
const (
    VectorRRFWeight = 0.7  // 向量搜索 RRF 权重
    BM25RRFWeight   = 0.3  // BM25 搜索 RRF 权重
    HotWeight       = 0.2  // 热度权重
    RRFConstant     = 60   // RRF 常量（Elasticsearch 默认值）
)

// RRF 分数计算
rrfScore := 0.0

// 向量搜索贡献（基于排名）
if vectorRank exists {
    rrfScore += VectorRRFWeight / (vectorRank + RRFConstant)
}

// BM25 搜索贡献（基于排名）
if bm25Rank exists {
    rrfScore += BM25RRFWeight / (bm25Rank + RRFConstant)
}

// 热度贡献
hotScore := access_count / max_access_count
rrfScore += HotWeight * hotScore
```

**关键设计：**
- **RRF 算法**：基于排名而非分数，避免不同搜索方式分数不可比的问题
- **向量权重最高（70%）**：语义搜索是核心
- **BM25 权重次之（30%）**：关键词匹配补充
- **热度加成（20%）**：访问次数 / 最大访问次数（无时间衰减）
- **多 topic 支持**：逗号分隔的多个 topic 并行搜索，结果用 RRF 合并
- **搜索缓存**：24 小时 TTL，按 library:version 标签失效

---

## 五、非功能需求

### 5.1 性能目标

| 指标 | 目标 | 实现方式 |
|------|------|---------|
| **文档更新** | 1 分钟内完成一个库 | 异步处理 + 批量 Embedding |
| **检索延迟** | 1 秒内返回结果 | Redis 缓存 + pgvector 索引 |
| **吞吐量** | 支持并发查询 | PostgreSQL 可达 1500+ QPS |

### 5.2 可扩展性

#### 初期（单机）

```
PostgreSQL + pgvector (单实例)
Redis (单实例)
Go MCP Server (可多实例)
```

#### 后期（分布式）

```
PostgreSQL 主从 + 读写分离
Redis Cluster
Milvus 集群 (替代 pgvector)
```

### 5.3 可靠性

- PostgreSQL ACID 事务保证
- 定期备份（每日）
- 故障转移（主从切换）
- 监控告警（关键指标）

### 5.4 缓存策略

**Redis 缓存设计：**

```go
// 缓存 key 构成
cache_key = "search:{library_id}:{query_hash}"

// 缓存值
{
  "results": [...],
  "timestamp": "2024-12-01T12:00:00Z",
  "hit_count": 5
}

// 缓存参数
TTL: 24 小时
预热: 否（按需缓存）
淘汰策略: LRU（最近最少使用）
```

**缓存场景：**
1. 热门查询缓存（减少向量搜索计算）
2. 库列表缓存（减少数据库查询）
3. 文档块缓存（减少数据库 I/O）

---

## 七、项目实施状态（2025-01-05 更新）

### 7.1 已实现功能清单

**MCP Server 实现：**
- ✅ JSON-RPC 2.0 协议支持
- ✅ Streamable HTTP 传输协议
- ✅ `search-libraries` 工具（向量搜索 + 模糊匹配降级）
- ✅ `get-library-docs` 工具（支持全局搜索和库内搜索）
- ✅ MCP 调用日志记录
- ✅ API Token 认证（支持 MCP_API_KEY header）

**数据库和存储：**
- ✅ PostgreSQL + pgvector 集成
- ✅ 数据模型：Library、DocumentUpload、DocumentChunk
- ✅ 向量索引（HNSW）
- ✅ 全文搜索索引（GIN）
- ✅ 七牛云文件存储集成

**文档处理流程：**
- ✅ Markdown 解析（gomarkdown）
- ✅ PDF 解析（docconv）
- ✅ DOCX 解析（docconv）
- ✅ 文档分块（512 tokens + 50 overlap）
- ✅ LLM Enrich（自动生成 title、description、content_type）
- ✅ Embedding 生成（OpenAI text-embedding-3-small）
- ✅ SSE 实时进度推送

**搜索和检索：**
- ✅ 向量搜索（pgvector cosine similarity）
- ✅ 全文搜索（PostgreSQL tsvector）
- ✅ 混合搜索（向量 + 关键词）
- ✅ 简化重排序（向量相似度 + BM25 + 热度）
- ✅ 分页支持（1-10 页）
- ✅ Mode 过滤（code/info）
- ✅ 版本过滤

**前端管理界面：**
- ✅ Vue 3 + TypeScript + Vite
- ✅ 库管理页面（列表、创建、删除）
- ✅ 文档上传页面（支持多文件、SSE 进度）
- ✅ 搜索测试页面
- ✅ 统计分析页面
- ✅ API Token 管理页面
- ✅ 用户中心（SSO 登录、个人信息）

**用户认证系统：**
- ✅ SSO 单点登录（OAuth 2.0）
- ✅ JWT Token（AccessToken + RefreshToken）
- ✅ API Token 生成和管理
- ✅ Token 撤销机制（Redis 黑名单）

**部署和运维：**
- ✅ Docker 容器化（server-mcp + web-mcp）
- ✅ docker-compose 编排
- ✅ 健康检查（/api/base/health）
- ✅ Swagger API 文档（/swagger/index.html）
- ✅ 日志系统（zap）
- ✅ 统计系统（BufferedWriter）

**GitHub 集成：**
- ✅ GitHub Release 列表获取
- ✅ GitHub 文档自动导入（支持 tarball 流式下载）
- ✅ 版本管理（创建、删除、刷新）
- ✅ 初始化导入（从 URL 创建库 + LLM 生成库名）

### 7.2 待实现功能

**文档格式扩展：**
- ⚠️ Swagger/OpenAPI 解析
- ⚠️ JavaDoc 解析
- ⚠️ HTML 文档解析

**高级功能：**
- ⚠️ 高级重排序（5 指标：+ 时效性 + 相关性）
- ⚠️ 语义分块（Semantic Chunker）
- ⚠️ 本地 Embedding 模型（bge-m3）

**分布式部署：**
- ⚠️ PostgreSQL 主从复制
- ⚠️ Redis Cluster
- ⚠️ Milvus 向量数据库

### 7.3 技术栈实现清单

| 组件 | 技术选型 | 状态 | 备注 |
|------|---------|------|------|
| **后端框架** | Gin | ✅ 已实现 | 高性能 HTTP 框架 |
| **MCP SDK** | mcp-golang | ✅ 已实现 | 支持 JSON-RPC 2.0 + Streamable |
| **数据库** | PostgreSQL 15 | ✅ 已实现 | 主数据库 |
| **向量扩展** | pgvector 0.5.1 | ✅ 已实现 | HNSW 索引 |
| **Embedding** | OpenAI text-embedding-3-small | ✅ 已实现 | 1536 维向量 |
| **LLM** | OpenAI gpt-4o-mini | ✅ 已实现 | Enrich 生成 |
| **缓存** | Redis 7 | ✅ 已实现 | 查询缓存 + Token 黑名单 |
| **文件存储** | 七牛云 | ✅ 已实现 | 文档存储 |
| **文档解析** | docconv + gomarkdown | ✅ 已实现 | PDF/DOCX/Markdown |
| **ORM** | GORM | ✅ 已实现 | 数据库操作 |
| **日志** | zap | ✅ 已实现 | 结构化日志 |
| **前端框架** | Vue 3 + TypeScript | ✅ 已实现 | 管理界面 |
| **构建工具** | Vite | ✅ 已实现 | 前端构建 |
| **容器化** | Docker + docker-compose | ✅ 已实现 | 部署方案 |

### 7.4 代码统计

**后端代码（server-mcp）：**
- Go 源文件：39 个
- 代码行数：约 15,000 行
- 测试覆盖率：约 60%

**前端代码（web-mcp）：**
- Vue 组件：约 30 个
- TypeScript 代码：约 8,000 行

**数据库表：**
- 核心表：6 个（libraries、document_uploads、document_chunks、api_tokens、mcp_call_logs、statistics）
- 索引：15+ 个

### 7.5 性能指标（实测）

| 指标 | 目标 | 实际 | 状态 |
|------|------|------|------|
| **文档上传** | 1 分钟/库 | 30-60 秒 | ✅ 达标 |
| **检索延迟** | < 1 秒 | 200-500 ms | ✅ 超预期 |
| **向量搜索** | 1500+ QPS | 未压测 | ⚠️ 待测试 |
| **并发支持** | 100+ | 未压测 | ⚠️ 待测试 |

---

## 八、项目结构与设计决策

### 8.1 实际项目目录结构（2025-01-05）

**单一项目，分层架构（已实现）**

```
go-mcp-context/
├── server-mcp/                 # 后端服务
│   ├── main.go                 # 应用入口
│   ├── internal/
│   │   ├── api/                # API 层（11 个文件）
│   │   │   ├── mcp.go          # MCP 协议处理
│   │   │   ├── library.go      # 库管理 API
│   │   │   ├── document.go     # 文档管理 API
│   │   │   ├── search.go       # 搜索 API
│   │   │   ├── auth.go         # SSO 认证
│   │   │   ├── apikey.go       # API Token 管理
│   │   │   ├── user.go         # 用户信息
│   │   │   ├── stats.go        # 统计数据
│   │   │   └── activity_log.go # 活动日志
│   │   ├── service/            # 服务层（10+ 个文件）
│   │   │   ├── mcp.go          # MCP 工具实现
│   │   │   ├── mcp_handler.go  # MCP 请求处理
│   │   │   ├── library.go      # 库管理服务
│   │   │   ├── document.go     # 文档处理服务
│   │   │   ├── search.go       # 搜索服务
│   │   │   ├── github.go       # GitHub 集成
│   │   │   └── apikey.go       # API Token 服务
│   │   ├── model/              # 数据模型
│   │   │   ├── database/       # 数据库模型（10 个文件）
│   │   │   ├── request/        # 请求模型（8 个文件）
│   │   │   └── response/       # 响应模型（8 个文件）
│   │   ├── middleware/         # 中间件（4 个文件）
│   │   │   ├── sso_jwt.go      # JWT 验证
│   │   │   ├── apikey.go       # API Key 验证
│   │   │   ├── logger.go       # 请求日志
│   │   │   └── mcplog.go       # MCP 调用日志
│   │   ├── initialize/         # 初始化（8 个文件）
│   │   │   ├── gorm.go         # 数据库初始化
│   │   │   ├── redis.go        # Redis 初始化
│   │   │   ├── embedding.go    # Embedding 服务
│   │   │   ├── llm.go          # LLM 服务
│   │   │   ├── storage.go      # 文件存储
│   │   │   └── router.go       # 路由初始化
│   │   └── transport/          # MCP 传输层
│   │       ├── transport.go    # 传输接口
│   │       └── streamable/     # Streamable HTTP 实现
│   ├── pkg/
│   │   ├── config/             # 配置管理
│   │   ├── global/             # 全局变量
│   │   ├── utils/              # 工具函数
│   │   ├── parser/             # 文档解析器
│   │   │   ├── markdown.go     # Markdown 解析
│   │   │   ├── pdf.go          # PDF 解析
│   │   │   └── docx.go         # DOCX 解析
│   │   ├── embedding/          # Embedding 服务
│   │   │   └── openai.go       # OpenAI Embedding
│   │   ├── llm/                # LLM 服务
│   │   │   └── openai.go       # OpenAI LLM
│   │   ├── storage/            # 文件存储
│   │   │   └── qiniu.go        # 七牛云存储
│   │   ├── chunker/            # 文档分块
│   │   │   └── token_based.go  # Token 分块
│   │   └── bufferedwriter/     # 统计系统
│   ├── test/                   # 测试文件（20+ 个）
│   ├── docs/                   # Swagger 文档
│   ├── configs/                # 配置文件
│   ├── Dockerfile
│   ├── go.mod
│   └── go.sum
├── web-mcp/                    # 前端服务
│   ├── src/
│   │   ├── views/              # 页面组件
│   │   │   ├── dashboard/      # Dashboard 页面
│   │   │   ├── library/        # 库管理
│   │   │   ├── document/       # 文档管理
│   │   │   ├── search/         # 搜索测试
│   │   │   └── user/           # 用户中心
│   │   ├── api/                # API 调用
│   │   ├── router/             # 路由配置
│   │   ├── store/              # Pinia 状态管理
│   │   └── utils/              # 工具函数
│   ├── package.json
│   ├── vite.config.ts
│   └── Dockerfile
├── docker-compose.prod.yml     # 生产环境编排
├── deploy.sh                   # 部署脚本
└── README.md
```

**关键目录说明：**
- `internal/transport/`: MCP 协议传输层，支持 JSON-RPC 2.0 和 Streamable HTTP
- `internal/service/mcp_handler.go`: MCP 请求统一处理器
- `pkg/bufferedwriter/`: 统计数据缓冲写入系统
- `test/`: 单元测试和集成测试

### 8.2 实际 API 端点清单（2025-01-05）

#### MCP 协议端点

```
POST /mcp
Content-Type: application/json
MCP_API_KEY: {your_api_key}  # 注意：是 MCP_API_KEY header，不是 Authorization

支持的方法（已实现）：
- initialize          # MCP 初始化
- initialized         # 初始化完成通知
- tools/list          # 获取工具列表
- tools/call          # 调用工具
  - search-libraries  # 搜索库（向量搜索 + 模糊匹配降级）
  - get-library-docs  # 获取文档（混合搜索 + 重排序）
- resources/list      # 资源列表（返回空）
- resourceTemplates/list  # 模板列表（返回空）
```

#### 前端 API 端点

**认证类：**
```
GET  /api/auth/sso_login_url      # 获取 SSO 登录地址
GET  /api/auth/callback           # SSO 回调
POST /api/auth/refresh            # 刷新 Token
```

**库管理类：**
```
GET    /api/v1/libraries              # 获取库列表
POST   /api/v1/libraries              # 创建库
GET    /api/v1/libraries/:id          # 获取库详情
PUT    /api/v1/libraries/:id          # 更新库
DELETE /api/v1/libraries/:id          # 删除库
GET    /api/v1/libraries/:id/versions # 获取版本列表
POST   /api/v1/libraries/:id/versions # 创建版本
DELETE /api/v1/libraries/:id/versions/:version  # 删除版本
POST   /api/v1/libraries/:id/versions/:version/refresh  # 刷新版本
POST   /api/v1/libraries/:id/versions/:version/refresh-sse  # SSE 刷新
```

**GitHub 集成类（✅ 已实现）：**
```
GET  /api/v1/libraries/github/releases      # 获取 GitHub 版本列表
POST /api/v1/libraries/github/init-import  # 初始化导入（创建库 + 验证连通性）
POST /api/v1/libraries/github/import       # 导入文档（同步）
POST /api/v1/libraries/github/import-sse   # SSE 导入（实时进度）
```

**文档管理类（✅ 已实现）：**
```
GET    /api/v1/documents/list             # 获取文档列表
POST   /api/v1/documents/upload           # 上传文档（同步）
POST   /api/v1/documents/upload-sse       # SSE 上传（实时进度）
GET    /api/v1/documents/detail/:id       # 获取文档详情
GET    /api/v1/documents/chunks/:mode/:libid  # 获取文档块（code/info）
```

**搜索类（✅ 已实现）：**
```
POST /api/v1/search  # 搜索文档（混合搜索：向量 + 全文 + 重排序）
```

**API Token 管理类（✅ 已实现）：**
```
POST   /api/v1/api-keys/create  # 创建 API Key
GET    /api/v1/api-keys/list    # 获取 API Key 列表
DELETE /api/v1/api-keys/:id     # 删除 API Key（撤销）
```

**统计类（✅ 已实现）：**
```
GET /api/v1/stats  # 获取统计数据（库、文档、MCP 调用等）
```

**其他端点（✅ 已实现）：**
```
GET /api/base/health     # 健康检查端点（Docker healthcheck 使用）
GET /swagger/index.html  # Swagger API 文档
GET /api/v1/activity-logs  # 活动日志查询
GET /api/v1/user/info    # 获取当前用户信息
```

---

### 8.2 设计确认清单

| # | 项目 | 方案 | 状态 |
|---|------|------|------|
| 1 | 项目结构 | 单一项目，分层架构 | ✅ |
| 2 | search-libraries | 模糊匹配 + 向量搜索，阈值 ≥80% | ✅ |
| 3 | get-library-docs | 混合搜索 + 重排序 | ✅ |
| 4 | 重排序权重 | 0.5 + 0.3 + 0.2 | ✅ |
| 5 | 输出格式 | 结构化 JSON（包含相关性分数） | ✅ |
| 6 | 缓存策略 | Redis，TTL 24 小时，无预热 | ✅ |
| 7 | 文档热度 | 访问计数，无时间衰减 | ✅ |
| 8 | 分页 | MCP 支持 page 1-10，前端支持分页 | ✅ |
| 9 | mode 参数 | 支持 code 和 info | ✅ |
| 10 | 前端功能 | 库管理 + 上传 + 搜索测试 | ✅ |

---

### 8.3 关键设计决策

**决策 1：混合搜索 → 向量 + 关键词 ✅**

**为什么？**
- 向量搜索：捕捉语义相似性
- 关键词搜索：确保精确匹配
- 混合搜索：结合两者优势

**实现：**
- 向量搜索 Top-50（cosine 相似度）
- 关键词搜索 Top-50（BM25 分数）
- 合并去重后重排序

---

**决策 2：Embedding → OpenAI text-embedding-3-small ✅**

**为什么不用本地模型？**
- 成本极低（$0.02/1M tokens，每月几元）
- 性能优异，接近 GPT-4 水平
- 可随时切换到本地 bge-m3（兼容性好）

**成本估算：**
- 处理 1000 个文档（5000 tokens/个）：$0.10
- 每天 10000 次查询：$0.02/天（$0.60/月）

---

**决策 3：重排序 → 简化版 3 指标 ✅**

**为什么不用 Context7 的 5 指标？**
- MVP 阶段优先快速上线
- 3 指标已能满足 80% 场景
- 后期可升级到 5 指标

**3 指标组成：**
- 向量相似度：50%（语义搜索是核心）
- BM25 分数：30%（关键词匹配补充）
- 文档热度：20%（辅助排序因子）

---

**决策 4：前端功能 → 简单库列表 ✅**

**为什么不需要 Popular/Trending/Recent？**
- MVP 阶段简化功能
- 简单列表足够库管理需求
- 后期可添加分类功能

---

**决策 5：缓存策略 → 按需缓存，无预热 ✅**

**为什么不预热？**
- 查询多样化，预热效果有限
- 按需缓存简单高效
- 24 小时 TTL 平衡新鲜度和性能

---

## 十、数据库 Schema（2025-12-15 更新）

> **重大调整**：采用两层架构，Library 只存库名（不含版本），Chunk 直接挂在 Library 下并带版本号。

### 10.1 库表（Library）

```sql
CREATE TABLE libraries (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,      -- 库名（不含版本），如 "react"
    description TEXT,
    default_version VARCHAR(50),            -- 默认版本，如 "19.0.1"
    versions TEXT[],                        -- 可用版本列表（PostgreSQL 数组）
    source_type VARCHAR(20) DEFAULT 'local', -- github, website, local
    source_url VARCHAR(500),                -- GitHub 仓库或网站 URL
    embedding_model VARCHAR(100) DEFAULT 'text-embedding-3-small',
    embedding vector(1536),                 -- 库名+描述的向量表示（用于语义搜索）
    created_by VARCHAR(36),                 -- 创建者 UUID，空值表示公共库
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'archived', 'deleted')),
    deleted_at TIMESTAMP NULL,
    INDEX idx_name (name),
    INDEX idx_status (status),
    INDEX idx_created_by (created_by)
);
```

**字段说明：**
- `name` - 库名（唯一），不含版本号，如 `react`、`nextjs`
- `default_version` - 默认版本，搜索时未指定版本则使用此版本
- `versions` - 可用版本列表，PostgreSQL TEXT[] 数组格式
- `source_type` - 来源类型：`github`、`website`、`local`
- `source_url` - 来源 URL（GitHub 仓库或网站地址）
- `embedding` - 库名+描述的向量表示，用于语义搜索
- `created_by` - 创建者 UUID，空值表示公共库

---

### 10.2 文档上传表（DocumentUpload）

```sql
CREATE TABLE document_uploads (
    id SERIAL PRIMARY KEY,
    library_id INTEGER NOT NULL REFERENCES libraries(id) ON DELETE CASCADE,
    version VARCHAR(50) NOT NULL,           -- 版本号，如 "19.0.1"
    title VARCHAR(500),                     -- 文档标题
    file_path TEXT NOT NULL,                -- 存储路径（Key）
    file_type VARCHAR(50),                  -- md, pdf, docx, swagger
    file_size BIGINT,                       -- 文件大小（字节）
    content_hash VARCHAR(64),               -- SHA256 Hash，用于检测文档变化
    chunk_count INTEGER DEFAULT 0,          -- 生成的 Chunk 数量
    token_count INTEGER DEFAULT 0,          -- 总 token 数
    error_message TEXT,                     -- 解析失败时的错误信息
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'deleted')),
    deleted_at TIMESTAMP NULL,
    INDEX idx_library_id (library_id),
    INDEX idx_version (version),
    INDEX idx_content_hash (content_hash)
);
```

**字段说明：**
- `version` - 完整版本号，如 `19.0.1`（纯数字格式，前端渲染时加 `v`）
- `title` - 文档标题
- `file_path` - 存储路径（Key）
- `token_count` - 总 token 数
- `status` - 状态：
  - `pending` - 待处理
  - `processing` - 处理中
  - `completed` - 已完成
  - `failed` - 解析失败
  - `deleted` - 已删除

---

### 10.3 文档块表（DocumentChunk，两层架构核心）

```sql
CREATE TABLE document_chunks (
    id SERIAL PRIMARY KEY,
    library_id INTEGER NOT NULL REFERENCES libraries(id) ON DELETE CASCADE,
    upload_id INTEGER REFERENCES document_uploads(id),  -- 关联上传记录
    version VARCHAR(50) NOT NULL,           -- 版本号（冗余，方便查询）
    chunk_index INTEGER NOT NULL,           -- 块序号
    
    -- Context7 风格的 Enrich 字段
    title VARCHAR(500),                     -- LLM 生成的标题
    description TEXT,                       -- LLM 生成的描述
    source TEXT,                            -- 来源路径/URL
    language VARCHAR(20),                   -- 代码语言 (js, go, python, markdown)
    code TEXT,                              -- 代码块内容（如果有）
    
    -- 原始内容、预计算 tsvector 与向量
    chunk_text TEXT NOT NULL,               -- 原始文本内容
    chunk_tsvector_simple TSVECTOR,         -- simple 配置预计算 tsvector（由 PostgreSQL 生成）
    tokens INTEGER,                         -- token 数量
    embedding vector(1536),                 -- OpenAI text-embedding-3-small
    
    -- 分类和统计
    chunk_type VARCHAR(10) DEFAULT 'mixed' CHECK (chunk_type IN ('code', 'info', 'mixed')),
    access_count INTEGER DEFAULT 0,         -- 访问次数（用于热度计算）
    metadata JSONB,                         -- 扩展元数据
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'pending', 'deleted')),
    
    -- 版本控制（用于无感知更新）
    batch_version BIGINT DEFAULT 0,         -- 批次版本号，支持原子切换
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP NULL,
    
    -- 向量索引（用于相似度搜索）
    INDEX idx_chunks_embedding ON embedding USING hnsw (embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64),
    
    -- 全文搜索索引（混合检索）
    INDEX idx_chunks_tsvector ON chunk_tsvector_simple USING gin,
    
    -- 查询优化索引
    INDEX idx_library_version (library_id, version),
    INDEX idx_upload_id (upload_id),
    INDEX idx_batch_version (batch_version),
    INDEX idx_status (status)
);
```

**字段说明（对标 Context7 Snippet 结构）：**
- `chunk_index` - 块序号，用于排序
- `title` - 标题，**LLM 生成**，描述这段代码做什么
- `description` - 描述，**LLM 生成**的上下文解释（1-3 句话）
- `source` - 来源路径/URL
- `language` - 代码语言
- `code` - 代码块内容（如果有）
- `chunk_text` - 原始文本内容
- `chunk_tsvector_simple` - 预计算的 tsvector，用于全文搜索
- `chunk_type` - 内容类型：`code`（代码示例）、`info`（概念说明）、`mixed`（混合）
- `batch_version` - 批次版本号，支持无感知更新
- `access_count` - 访问次数，用于热度计算（重排序权重 20%）

---

### 10.4 搜索缓存表

```sql
CREATE TABLE search_cache (
    id SERIAL PRIMARY KEY,
    query_hash VARCHAR(64) UNIQUE NOT NULL,  -- 查询的 hash 值
    library_id INTEGER NOT NULL REFERENCES libraries(id) ON DELETE CASCADE,
    results JSONB NOT NULL,                  -- 缓存的搜索结果
    hit_count INTEGER DEFAULT 0,             -- 缓存命中次数
    ttl TIMESTAMP NOT NULL,                  -- 缓存过期时间
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    INDEX idx_query_hash (query_hash),
    INDEX idx_library_id (library_id),
    INDEX idx_ttl (ttl)
);
```

**用途：**
- 缓存热门查询的结果
- 减少向量搜索的计算量
- 提高检索性能

---

### 10.5 API Key 表

```sql
CREATE TABLE api_keys (
    id SERIAL PRIMARY KEY,
    user_uuid UUID NOT NULL,                 -- 用户 UUID（关联 SSO 用户）
    token_hash VARCHAR(64) NOT NULL UNIQUE,  -- SHA256 哈希，不返回前端
    token_suffix VARCHAR(4) NOT NULL,        -- 后 4 位，用于显示
    name VARCHAR(100) NOT NULL,              -- 用户自定义名称
    usage_count BIGINT DEFAULT 0,            -- 使用次数
    last_used_at TIMESTAMP,                  -- 上次使用时间
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP NULL,
    
    INDEX idx_user_uuid (user_uuid),
    INDEX idx_token_hash (token_hash)
);
```

**字段说明：**
- `token_hash` - Token 的 SHA256 哈希，用于验证
- `token_suffix` - Token 后 4 位，用于前端显示（如 `****abcd`）
- `name` - 用户自定义名称，便于识别
- `usage_count` - 使用次数统计
- `last_used_at` - 上次使用时间

**用途：**
- 存储用户生成的 MCP API Key
- 支持 API Key 管理（生成、查看、删除）
- 用于 MCP 调用认证

---

### 10.6 统计表

```sql
CREATE TABLE statistics (
    id SERIAL PRIMARY KEY,
    library_id INTEGER REFERENCES libraries(id) ON DELETE CASCADE,
    metric_name VARCHAR(100) NOT NULL,      -- 指标名称
    metric_value BIGINT,                    -- 指标值
    recorded_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE INDEX idx_stats_lib_metric (library_id, metric_name),
    INDEX idx_recorded_at (recorded_at)
);
```

**字段说明：**
- `metric_name` - 指标名称（如 `mcp.func.get_library_docs`）
- `metric_value` - 指标值
- `recorded_at` - 记录时间

**用途：**
- 记录系统统计信息
- 支持性能监控和分析

---

### 10.7 活动日志表（ActivityLog）

```sql
CREATE TABLE activity_logs (
    id SERIAL PRIMARY KEY,
    library_id INTEGER NOT NULL REFERENCES libraries(id) ON DELETE CASCADE,
    actor_id VARCHAR(36),                   -- 操作者 UUID
    event VARCHAR(64) NOT NULL,             -- 事件类型
    status VARCHAR(16) DEFAULT 'info',      -- info, success, warning, error
    message TEXT NOT NULL,                  -- 日志消息
    target_type VARCHAR(32),                -- 目标类型（document, version等）
    target_id VARCHAR(64),                  -- 目标ID
    task_id VARCHAR(26),                    -- 任务ID（用于关联同一任务的多条日志）
    version VARCHAR(32),                    -- 版本号
    metadata JSONB DEFAULT '{}',            -- 扩展元数据
    created_at TIMESTAMP DEFAULT NOW(),
    
    INDEX idx_library_id (library_id),
    INDEX idx_event (event),
    INDEX idx_task_id (task_id),
    INDEX idx_logs_library_time USING BRIN(library_id, created_at)
);
```

**事件类型：**
- 文档事件：`document.upload`, `document.parse`, `document.chunk`, `document.embed`, `document.complete`, `document.failed`, `document.delete`
- 版本事件：`version.create`, `version.delete`, `version.refresh`
- GitHub 导入：`github.import.start`, `github.import.download`, `github.import.complete`, `github.import.failed`
- 库事件：`library.create`, `library.update`, `library.delete`

**用途：**
- 记录所有库操作的活动日志
- 支持按任务ID关联多条日志
- 用于审计和问题排查

---

### 10.8 MCP 调用日志表（MCPCallLog）

```sql
CREATE TABLE mcp_call_logs (
    id SERIAL PRIMARY KEY,
    actor_id VARCHAR(36) NOT NULL,          -- 调用者 UUID
    func_name VARCHAR(64) NOT NULL,         -- 函数名（映射后的常量）
    library_id INTEGER REFERENCES libraries(id) ON DELETE SET NULL,
    params JSONB,                           -- 请求参数 JSON（完整请求体）
    result_count INTEGER DEFAULT 0,         -- 返回结果数
    latency_ms INTEGER DEFAULT 0,           -- 响应时间（毫秒）
    status VARCHAR(16) DEFAULT 'success',   -- success, error
    error_msg VARCHAR(500),                 -- 错误信息
    created_at TIMESTAMP DEFAULT NOW(),
    
    INDEX idx_actor_id (actor_id),
    INDEX idx_func_name (func_name),
    INDEX idx_library_id (library_id),
    INDEX idx_created_at (created_at)
);
```

**字段说明：**
- `func_name` - 存储映射后的函数名常量（不是原始method）
- `params` - 完整的请求体JSON（包含method和params）

**函数名映射：**
| 原始 method | func_name 常量 |
|------------|---------------|
| `initialize` | `initialize` |
| `notifications/initialized` | `initialized` |
| `tools/list` | `tools_list` |
| `tools/call` | `tools_call` |
| `resources/list` | `resources_list` |
| `resources/templates/list` | `resource_templates_list` |
| `search-libraries` | `search_libraries` |
| `get-library-docs` | `get_library_docs` |

**用途：**
- 记录所有 MCP 协议调用
- 统计调用频率和性能
- 用于计费和限流
- 支持按函数名聚合统计

**实现文件：** `server-mcp/internal/middleware/mcplog.go`

---

### 10.9 数据库初始化

项目使用 **GORM AutoMigrate** 自动创建和迁移数据库表，无需手动执行 SQL 脚本。

**初始化流程：**

```go
// internal/initialize/gorm.go

// 1. 启用 pgvector 扩展
db.Exec("CREATE EXTENSION IF NOT EXISTS vector")

// 2. 自动迁移所有表
global.DB.AutoMigrate(
    &dbmodel.Library{},
    &dbmodel.DocumentUpload{},
    &dbmodel.DocumentChunk{},
    &dbmodel.SearchCache{},
    &dbmodel.APIKey{},
    &dbmodel.Statistics{},
    &dbmodel.ActivityLog{},
    &dbmodel.MCPCallLog{},
)

// 3. 创建索引
createIndexes()
```

**创建的索引：**

```sql
-- 向量索引 (HNSW) - document_chunks
CREATE INDEX IF NOT EXISTS idx_chunks_embedding 
ON document_chunks 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 向量索引 (HNSW) - libraries
CREATE INDEX IF NOT EXISTS idx_libraries_embedding 
ON libraries 
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 全文搜索索引
CREATE INDEX IF NOT EXISTS idx_chunks_text 
ON document_chunks 
USING gin(chunk_tsvector_simple);

-- 条件全文索引（active 状态）
CREATE INDEX IF NOT EXISTS idx_chunks_text_simple_active
ON document_chunks
USING gin(chunk_tsvector_simple)
WHERE status = 'active' AND deleted_at IS NULL;

-- code 类型全文索引
CREATE INDEX IF NOT EXISTS idx_chunks_text_simple_active_code
ON document_chunks
USING gin(chunk_tsvector_simple)
WHERE status = 'active' AND deleted_at IS NULL AND chunk_type = 'code';

-- info 类型全文索引
CREATE INDEX IF NOT EXISTS idx_chunks_text_simple_active_info
ON document_chunks
USING gin(chunk_tsvector_simple)
WHERE status = 'active' AND deleted_at IS NULL AND chunk_type = 'info';

-- 复合过滤索引
CREATE INDEX IF NOT EXISTS idx_chunks_library_version_type
ON document_chunks (library_id, version, chunk_type, chunk_index)
WHERE status = 'active' AND deleted_at IS NULL;

-- 活动日志 BRIN 索引（时序数据优化）
CREATE INDEX IF NOT EXISTS idx_logs_library_time 
ON activity_logs 
USING BRIN(library_id, created_at);
```

**实现文件：** `server-mcp/internal/initialize/gorm.go`

---

### 10.10 表设计总结

| 表名 | 用途 | 行数估计 | 大小估计 |
|------|------|--------|--------|
| libraries | 库管理 | 100-1000 | 1-10 MB |
| document_uploads | 文档上传记录 | 10K-100K | 10-100 MB |
| document_chunks | 向量存储 | 1M-10M | 1-10 GB |
| search_cache | 查询缓存 | 10K-100K | 100-500 MB |
| api_keys | API Key | 1K-10K | 1-10 MB |
| statistics | 统计数据 | 1K-10K | 10-50 MB |
| activity_logs | 活动日志 | 100K-1M | 100-500 MB |
| mcp_call_logs | MCP 调用日志 | 100K-1M | 100-500 MB |

**总计：8 个表**

---

### 10.11 性能优化建议

#### 1. 分区策略（大数据量时）
```sql
-- 按 library_id 分区
CREATE TABLE document_chunks_partitioned (
    ...
) PARTITION BY HASH (library_id);
```

#### 2. 定期清理
```sql
-- 清理已删除的数据（每周执行）
DELETE FROM document_chunks WHERE status = 'deleted' AND deleted_at < NOW() - INTERVAL '30 days';
DELETE FROM documents WHERE status = 'deleted' AND deleted_at < NOW() - INTERVAL '30 days';
DELETE FROM libraries WHERE status = 'deleted' AND deleted_at < NOW() - INTERVAL '30 days';
```

#### 3. 索引维护
```sql
-- 定期重建索引（每月执行）
REINDEX INDEX idx_chunks_embedding;
REINDEX INDEX idx_chunks_text;
```

#### 4. 统计信息更新
```sql
-- 更新表统计（每天执行）
ANALYZE libraries;
ANALYZE documents;
ANALYZE document_chunks;
```

---

## 十三、补充设计决策

### 13.1 Embedding 维度兼容性

**问题**：不同 Embedding 模型维度不同（OpenAI 1536 维，bge-m3 1024 维），切换模型时如何处理？

**方案**：换模型 = 重新生成所有 embedding

**理由**：
- 不同模型的向量空间**语义不兼容**，混用会导致搜索质量下降
- 业界主流做法就是重新生成

**实现**：
1. 数据库字段保持 `vector(1536)`
2. 切换模型时，提供**批量重新生成脚本**
3. 在 `libraries` 表增加 `embedding_model` 字段，记录当前使用的模型

---

### 13.2 文档更新策略

**问题**：同一文档重新上传时如何处理？

**方案**：覆盖 + 内容 Hash 检测

**实现**：
1. 上传时计算文档内容的 **SHA256 Hash**
2. 如果 Hash 相同，跳过处理
3. 如果 Hash 不同，**删除旧 chunks，生成新 chunks**
4. 不保留历史版本（MVP 简化）

---

### 13.3 库的版本管理

**问题**：同一个库可能有多个版本，如何管理？

**方案**：必须指定版本，搜索默认最新

**实现**：
1. 上传时**必须指定版本号**（如 `18.3.0`）
2. 库 ID 格式：`{name}/{version}`（如 `react/18.3.0`）
3. `search-libraries` 返回所有版本
4. `get-library-docs` 默认使用**最新版本**，可指定特定版本

---

### 13.4 认证方案

**问题**：MCP 接口如何认证？

**方案**：双 Token 机制

| Token 类型 | 用途 | 有效期 | 生成方式 |
|-----------|------|--------|---------|
| **AccessToken + RefreshToken** | 前端 Web 登录 | 短期（如 2h + 7d） | SSO 登录后自动生成 |
| **API Token** | IDE/MCP 调用 | 长期（如 90 天或永久） | 用户在用户中心手动生成 |

**API Token 结构**：
```go
type APITokenClaims struct {
    UserUUID  uuid.UUID `json:"user_uuid"`
    TokenID   string    `json:"token_id"`   // 唯一标识，用于撤销
    TokenName string    `json:"token_name"` // 用户自定义名称
    Scope     string    `json:"scope"`      // 默认 "mcp:read"
    jwt.RegisteredClaims
}
```

**撤销机制**：Redis 黑名单（参考 blog 项目）
```go
// 撤销 API Token
blacklistKey := "api_token:blacklist:" + tokenID
global.Redis.Set(blacklistKey, "1", 0)  // 永久黑名单

// 验证时检查黑名单
if global.Redis.Exists(blacklistKey).Val() > 0 {
    return errors.New("token已被撤销")
}
```

**数据库表**：
```sql
CREATE TABLE api_tokens (
    id          SERIAL PRIMARY KEY,
    user_uuid   UUID NOT NULL,
    token_id    VARCHAR(64) NOT NULL UNIQUE,
    token_name  VARCHAR(100) NOT NULL,
    scope       VARCHAR(50) DEFAULT 'mcp:read',
    expires_at  TIMESTAMP,
    revoked_at  TIMESTAMP,
    created_at  TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (user_uuid) REFERENCES users(uuid)
);
```

**用户中心功能**：
1. **生成 Token**：输入名称 + 选择有效期（30天/90天/永久）
2. **查看列表**：显示所有 Token（名称、创建时间、过期时间、状态）
3. **撤销 Token**：加入 Redis 黑名单 + 更新数据库 `revoked_at`

**IDE 配置示例**：
```json
{
  "mcpServers": {
    "go-mcp-context": {
      "type": "streamable-http",
      "url": "http://localhost:8080/mcp",
      "headers": {
        "Authorization": "Bearer {用户中心生成的 API Token}"
      }
    }
  }
}
```

---

### 13.5 文档解析失败处理

**问题**：批量上传时部分文档解析失败如何处理？

**方案**：部分成功 + 失败记录

**实现**：
1. 批量上传时，每个文档独立处理
2. 成功的正常入库，失败的**记录错误原因**
3. 返回结果包含：`success_count`, `failed_count`, `failed_files[]`
4. 失败的文档在 `documents` 表标记 `status = 'failed'`，记录 `error_message`

---

### 13.6 mode 参数（code/info）分类

**问题**：`get-library-docs` 的 mode 参数如何区分代码和信息？

**方案**：上传时自动分类 + 搜索时过滤

**分类规则**（基于 Markdown 结构）：
```go
// 代码类型检测
isCode := hasCodeBlock(chunk) ||                    // 包含 ``` 代码块
          matchesAPIPattern(chunk) ||               // 匹配 API 文档模式
          containsKeywords(chunk, ["function", "method", "parameter", "return", "example"])

// 信息类型检测
isInfo := matchesConceptPattern(chunk) ||          // 匹配概念说明模式
          containsKeywords(chunk, ["introduction", "overview", "guide", "tutorial"])
```

**数据库字段**：
```sql
chunk_type VARCHAR(10) DEFAULT 'mixed' CHECK (chunk_type IN ('code', 'info', 'mixed'))
```

**搜索时过滤**：
- `mode=code`：优先返回 `chunk_type IN ('code', 'mixed')`
- `mode=info`：优先返回 `chunk_type IN ('info', 'mixed')`

---

## 附录：技术参考

### pgvector 性能基准

**测试环境：50M 向量，768 维**

| 指标 | PostgreSQL + pgvector | Qdrant | 优势 |
|------|----------------------|--------|------|
| 吞吐量（99% 召回） | 471.57 QPS | 41.47 QPS | **11.4x** |
| P50 延迟 | 31.07 ms | 30.75 ms | Qdrant 1% |
| P95 延迟 | 60.42 ms | 36.73 ms | Qdrant 39% |
| P99 延迟 | 74.60 ms | 38.71 ms | Qdrant 48% |

### OpenAI Embedding 定价

| 模型 | 价格 | 维度 | 性能 |
|------|------|------|------|
| text-embedding-3-small | $0.02 / 1M tokens | 1536 | ⭐⭐⭐⭐⭐ |
| text-embedding-3-large | $0.13 / 1M tokens | 3072 | ⭐⭐⭐⭐⭐ |

### 推荐开源 Embedding 模型

| 模型 | 维度 | 大小 | 语言 | 性能 |
|------|------|------|------|------|
| BAAI/bge-m3 | 1024 | 2.3GB | 100+ | ⭐⭐⭐⭐⭐ |
| BAAI/bge-large-en-v1.5 | 1024 | 1.3GB | 英文 | ⭐⭐⭐⭐⭐ |
| sentence-transformers/all-MiniLM-L6-v2 | 384 | 80MB | 英文 | ⭐⭐⭐ |

---

## 十四、2025-12-15 设计决策记录

### 14.1 架构层级决策

**决策：采用两层架构（Library → Chunk）**

| 项目 | 原设计（三层） | 新设计（两层） |
|------|--------------|--------------|
| 数据模型 | Library → Document → Chunk | Library → Chunk |
| Library 含义 | 库名 + 版本 | 只存库名 |
| 版本存储 | Library.version | Chunk.version |
| 多版本支持 | 每个版本一个 Library | 同一 Library 下多版本 Chunks 共存 |

**对标 Context7：**
- Context7 的 Library ID 格式：`/org/project`（如 `/vercel/next.js`）
- 版本通过 `previousVersions` 配置，每个版本独立索引
- 多版本共存，互不干扰

---

### 14.2 版本管理策略

**决策：同一大版本只保留最新小版本**

```
示例：
上传 React 19.0.1 时：
1. 检查是否存在 19.x.x 版本
2. 找到 19.0.0 → 软删除（status = 'replaced'）
3. 删除七牛云 /mcp/docs/react/19.0.0/* 文件
4. 上传新版本到 /mcp/docs/react/19.0.1/
5. 更新 Library.versions：["19.0.1", "18.3.1", "17.0.2"]

结果：
- 19.0.1 替换 19.0.0
- 18.3.1、17.0.2 不受影响
```

**版本号格式：**
- 纯数字格式：`19.0.1`、`18.3.1`
- 前端渲染时加 `v` 前缀：`v19.0.1`

**版本比较逻辑：**
```go
// 判断是否为同一大版本
func isSameMajorVersion(v1, v2 string) bool {
    major1 := strings.Split(v1, ".")[0]  // "19.0.1" → "19"
    major2 := strings.Split(v2, ".")[0]
    return major1 == major2
}

// 比较版本号大小
func isNewerVersion(new, old string) bool {
    // 语义化版本比较：19.0.1 > 19.0.0
}
```

---

### 14.3 文件存储策略

**决策：使用七牛云存储，路径带完整版本号**

**存储路径格式：**
```
/mcp/docs/{lib}/{version}/{filename}

示例：
/mcp/docs/react/19.0.1/hooks.md
/mcp/docs/react/19.0.1/components.md
/mcp/docs/nextjs/15.0.0/routing.md
```

**配置复用：**
- 复用 blog 项目的七牛云配置和上传逻辑
- 配置项：`qiniu.bucket`、`qiniu.access_key`、`qiniu.secret_key`

---

### 14.4 AI 富化（Description 生成）

**决策：使用 LLM 生成 Chunk 的 Description 字段**

**Context7 的做法：**
- Enrich 阶段：LLM 为每个代码片段生成描述
- 描述内容：1-3 句话，说明代码用途和场景

**本项目实现：**
```go
// 复用 OpenAI 代理调用 Chat Completion
type LLMService struct {
    client *openai.Client
}

func (l *LLMService) GenerateDescription(title, code, language string) (string, error) {
    prompt := fmt.Sprintf(`
为以下代码片段生成一段简洁的描述（1-3句话），说明代码的用途和使用场景。

标题：%s
语言：%s
代码：
%s

要求：
- 使用第三人称描述
- 说明代码做什么、什么场景使用
- 不超过 100 字
`, title, language, code)
    
    resp, err := l.client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
        Model: "gpt-4o-mini",
        Messages: []openai.ChatCompletionMessage{
            {Role: "system", Content: "你是一个技术文档助手，专门为代码片段生成简洁准确的描述。"},
            {Role: "user", Content: prompt},
        },
    })
    return resp.Choices[0].Message.Content, err
}
```

**配置：**
```yaml
llm:
  base_url: ""      # 为空则复用 embedding.base_url
  api_key: ""       # 为空则复用 embedding.api_key
  model: "gpt-4o-mini"
```

---

### 14.5 Chunk 字段设计（对标 Context7 Snippet）

**Context7 Snippet 结构：**
```
TITLE: 标题
DESCRIPTION: 描述（AI 生成）
SOURCE: 来源 URL
LANGUAGE: 代码语言
CODE: 代码块
```

**本项目 DocumentChunk 字段：**

| 字段 | 类型 | 说明 | 对标 Context7 |
|------|------|------|--------------|
| `title` | VARCHAR(500) | 标题 | TITLE |
| `description` | TEXT | AI 生成的描述 | DESCRIPTION |
| `source` | TEXT | 七牛云文件路径 | SOURCE |
| `language` | VARCHAR(50) | 代码语言 | LANGUAGE |
| `code` | TEXT | 代码块内容 | CODE |
| `content_type` | VARCHAR(20) | code/info/mixed | - |
| `version` | VARCHAR(50) | 版本号 | - |
| `tokens` | INTEGER | Token 数量 | - |
| `embedding` | vector(1536) | 向量 | - |
| `access_count` | INTEGER | 访问次数 | - |

---

### 14.6 设计决策总结

| 项目 | 决策 | 状态 |
|------|------|------|
| 架构层级 | 两层（Library → Chunk） | ✅ 确定 |
| 版本策略 | 同一大版本只保留最新小版本 | ✅ 确定 |
| 版本号格式 | 纯数字（如 `19.0.1`） | ✅ 确定 |
| 旧版本处理 | 软删除 + 删除七牛云文件 | ✅ 确定 |
| 文件存储 | 七牛云，路径带完整版本号 | ✅ 确定 |
| AI 富化 | LLM 生成 Description | ✅ 确定 |
| LLM 调用 | 复用 OpenAI 代理 | ✅ 确定 |
| 上传表 | Document → DocumentUpload（改名） | ✅ 确定 |

---

### 14.7 文件存储接口设计（Storage Interface）

**决策：设计 Storage Interface 支持多云存储扩展**

```go
// Storage 文件存储接口
type Storage interface {
    // 核心方法
    Upload(ctx context.Context, key string, reader io.Reader, size int64, contentType string) (*UploadResult, error)
    Download(ctx context.Context, key string) (io.ReadCloser, error)
    Delete(ctx context.Context, key string) error
    
    // 批量操作
    DeleteByPrefix(ctx context.Context, prefix string) error  // 删除某个版本的所有文件
    ListByPrefix(ctx context.Context, prefix string) ([]FileInfo, error)
    
    // 元数据
    GetFileInfo(ctx context.Context, key string) (*FileInfo, error)
    Exists(ctx context.Context, key string) (bool, error)
    
    // URL 生成
    GetPublicURL(key string) string           // 获取公开访问 URL
    GetSignedURL(ctx context.Context, key string, expiry time.Duration) (string, error)  // 获取签名 URL
    
    // 健康检查
    Health(ctx context.Context) error
}

// 上传结果
type UploadResult struct {
    Key         string    // 存储 Key
    URL         string    // 访问 URL
    Size        int64     // 文件大小
    ContentType string    // 内容类型
    ETag        string    // 文件 Hash
    UploadedAt  time.Time // 上传时间
}

// 文件信息
type FileInfo struct {
    Key          string    // 存储 Key
    Size         int64     // 文件大小
    ContentType  string    // 内容类型
    LastModified time.Time // 最后修改时间
    ETag         string    // 文件 Hash
}
```

**七牛云 Go SDK API 支持情况：**

| 接口方法 | 七牛云 SDK 支持 | 对应 API |
|----------|----------------|----------|
| `Upload` | ✅ 支持 | `formUploader.Put()` / `resumeUploader.Put()` |
| `Download` | ✅ 支持 | `downloadManager.DownloadToWriter()` |
| `Delete` | ✅ 支持 | `bucket.Object(key).Delete()` |
| `DeleteByPrefix` | ✅ 支持（组合） | `bucket.List()` + `objectsManager.Batch()` 批量删除 |
| `ListByPrefix` | ✅ 支持 | `bucket.List(ctx, &objects.ListObjectsOptions{Prefix: prefix})` |
| `GetFileInfo` | ✅ 支持 | `bucket.Object(key).Stat()` |
| `Exists` | ✅ 支持 | `bucket.Object(key).Stat()` 判断是否返回错误 |
| `GetPublicURL` | ✅ 支持 | 拼接 `domain + "/" + key` |
| `GetSignedURL` | ✅ 支持 | `downloader.SignURLsProvider()` 签名 URL |
| `Health` | ✅ 支持 | 调用 `bucket.List()` 验证连接 |

**实现清单：**
- ✅ `QiniuStorage` - 七牛云存储（初期）
- ⚠️ `S3Storage` - AWS S3 / MinIO（后期）
- ⚠️ `LocalStorage` - 本地文件系统（测试用）

**QiniuStorage 结构体：**
```go
type QiniuStorage struct {
    accessKey      string
    secretKey      string
    bucket         string
    domain         string
    mac            *credentials.Credentials
    bucketManager  *objects.Bucket
    objectsManager *objects.ObjectsManager
    uploader       *uploader.UploadManager
    downloader     *downloader.DownloadManager
}
```

---

### 14.8 Enrich 提示词设计（对标 Context7）

**Context7 Snippet 结构（标准格式）：**
```
TITLE: 标题（描述这段代码做什么）
DESCRIPTION: 描述（1-3 句话，说明用途和场景）
SOURCE: 来源 URL
LANGUAGE: 代码语言
CODE: 代码块
```

**示例 - code 类型：**
```
TITLE: Resolve External Asset Paths using URL Constructor in JavaScript
DESCRIPTION: This JavaScript code demonstrates how to construct a `URL` object for an external asset using `import.meta.url` as the base. Next.js processes this to output a static asset path, useful for referencing non-module external files dynamically.
SOURCE: https://github.com/vercel/next.js/blob/canary/docs/01-app/03-api-reference/05-config/01-next-config-js/urlImports.mdx
LANGUAGE: js
CODE:
```js
const logo = new URL('https://example.com/assets/file.txt', import.meta.url)

console.log(logo.pathname)

// prints "/_next/static/media/file.a9727b5d.txt"
```
```

**示例 - info 类型：**
```
TITLE: Code Blocks > Language and Extension Combinations
DESCRIPTION: When writing JavaScript code blocks, use specific language and extension combinations: JavaScript files with JSX code should use `jsx` language with `.js` extension, JavaScript files without JSX should use `js` language with `.js` extension, TypeScript files with JSX should use `tsx` language with `.tsx` extension, and TypeScript files without JSX should use `ts` language with `.ts` extension.
SOURCE: https://github.com/vercel/next.js/blob/canary/docs/04-community/01-contribution-guide.mdx
LANGUAGE: markdown
CODE: (无代码块)
```

**Enrich 提示词设计：**
```go
const EnrichPromptTemplate = `你是一个技术文档专家，负责为代码片段生成结构化的描述信息。

请分析以下代码片段，生成符合 Context7 格式的结构化输出。

## 输入信息

**文件来源：** {{.Source}}
**代码语言：** {{.Language}}
**原始内容：**
{{.Content}}

## 输出要求

请返回 JSON 格式，包含以下字段：

{
  "title": "简洁的标题，描述这段代码做什么（英文，使用动词开头，如 'Create...', 'Configure...', 'Handle...'）",
  "description": "1-3 句话的描述，说明代码的用途和使用场景（英文）",
  "content_type": "code 或 info（code 表示包含可执行代码示例，info 表示概念说明或配置指南）",
  "language": "代码语言（如 js, ts, go, python, markdown 等）"
}

## 生成规则

### Title 规则：
- 使用动词开头：Create, Configure, Handle, Implement, Define, Set up, etc.
- 简洁明了，不超过 80 个字符
- 如果是 API 文档，包含函数/方法名
- 如果是配置，说明配置什么

### Description 规则：
- 第一句说明代码做什么
- 第二句说明什么场景使用
- 第三句（可选）说明注意事项或最佳实践
- 使用第三人称描述（This code..., This configuration..., This example...）
- 不超过 200 个字符

### Content Type 规则：
- code：包含可执行的代码示例（函数、类、配置代码等）
- info：概念说明、最佳实践、架构指南、无代码的文档

## 示例输出

### 示例 1（code 类型）：
{
  "title": "Create a Custom React Hook for Data Fetching",
  "description": "This custom hook demonstrates how to fetch data with loading and error states in React. Use it to encapsulate data fetching logic and reuse across components.",
  "content_type": "code",
  "language": "tsx"
}

### 示例 2（info 类型）：
{
  "title": "Understanding React Server Components Architecture",
  "description": "This guide explains the architecture of React Server Components and how they differ from Client Components. Use this to understand when to choose server vs client rendering.",
  "content_type": "info",
  "language": "markdown"
}

请严格按照 JSON 格式返回，不要包含其他内容。`
```

**LLM Service 数据结构：**
```go
type LLMService struct {
    client *openai.Client
    model  string
}

type EnrichInput struct {
    Source   string // 文件来源路径
    Language string // 代码语言
    Content  string // 原始内容
}

type EnrichOutput struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    ContentType string `json:"content_type"` // code 或 info
    Language    string `json:"language"`
}
```

**配置：**
```yaml
llm:
  provider: "openai"
  base_url: ""           # 为空则复用 embedding.base_url
  api_key: ""            # 为空则复用 embedding.api_key
  model: "gpt-4o-mini"   # 推荐使用 gpt-4o-mini，成本低且效果好
  max_tokens: 500        # 输出限制
  temperature: 0.3       # 低温度保证输出稳定
```

